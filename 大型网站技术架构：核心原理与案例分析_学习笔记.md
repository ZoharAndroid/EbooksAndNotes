<p align="center" ><font size="5">《大型网站技术架构：核心原理与案例分析》读书笔记</font></p>
<p align="right">学习者:zohar.zzh</p>
<p align="right">时 间:2019/1/21</p>

---

<p align="center"><font size="4">第1篇 概述</font></p>

---

# 1 大型网站架构演化

## 1.1 大型网站软件系统的特点

* **高并发，大流量**
* **高可用：** 7x24h不间断服务。
* **海量数据**
* **用户分布广泛，网络情况复杂**
* **安全环境恶劣**
* **需求快速变更，发布频繁**
* **渐进式发展**

## 1.2 大型网站架构演化发展历程

### 1.2.1 初始阶段的网站架构

![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%88%9D%E5%A7%8B%E9%98%B6%E6%AE%B5%E7%9A%84%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84.png)
应用程序、数据库、文件等所有资源都在一个服务器上。操作系统为Linux，应用程序使用PHP，部署在Apache上，数据库为MySql。

### 1.2.2 应用服务器和数据服务分类

应用和数据分离之后形成三个服务器：应用服务器、文件服务器和数据库服务器。
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E7%A6%BB.png)
* 应用服务器：处理大量的业务逻辑，需要较好的CPU。
* 数据库服务器：快速磁盘检索和数据缓存，需要较快的的硬盘和内存。
* 文件服务器：存储用户上传文件，需要较大硬盘。
> 问题：数据库访问延时。

### 1.2.3 使用缓存改善网站性能

大部分业务访问集中在一小部分数据上，把这一小部分数据缓存在内存中，减少数据库访问压力。

缓存分两种：

1. 缓存在应用服务器上的**本地缓存**；
2. 缓存在专门的分布式缓存服务器上的**远程缓存**。

* 本地缓存：访问速度更快一些，但是受到应用服务器内存限制，缓存数据量有限，会出现和应用程序争用内存的情况
* 远程分布式缓存：使用集群的方式，部署在大内存的服务器上。
  
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98.png)
> 问题：使用缓存后，数据库访问压力可以得到缓解，但是单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器成为整个网站的瓶颈。

### 1.2.4 使用应用服务器集群改善网站的并发处理能力

使用集群是网站解决高并发、海量数据问题的常用手段。当网站持续增长的业务需求，增加一台服务器分担原有的访问以及存储压力也是一种恰当的做法。
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2.png)
通过负载均衡调度服务器，将访问请求分发到应用服务器集群中的任何一台服务器中。

### 1.2.5 数据库读写分离

虽然使用缓存能够缓解部分压力，但是仍有一部分读操作（缓存不命中、缓存过期）和全部的写操作仍是需要访问数据库的。

大部分主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另外一台服务器上。利用这一功能，实现数据库读写分离，从而改善数据库负载压力。
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png)
应用服务器写数据的时候，访问主数据库服务器，主数据库通过主从复制机制将数据更新同步到从数据库，这样应用服务器读取数据的时候，就可以读取从数据库服务器。应用服务器使用专门的数据访问模块，可以使数据库读写分离。

### 1.2.6 使用反向代理和CDN加速网站响应

CDN和反向代理的基本原理都是缓存。

* **CDN**部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据。
* **反向代理**部署在网站的中心机房，当用户请求达到中心机房后，首先访问的是反向代理服务器，如果反向代理服务器缓存着用户请求的资源，就直接返回给用户。

![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8CCDN%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE.png)

> CDN和反向代理都是为了尽快的返回数据给用户，一方面加快用户访问速度，另一方面减轻服务器的负载压力。

### 1.2.7 使用分布式文件系统和分布式数据库系统

将数据库和文件系统拆分到多个服务器上。
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.png)

> 分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同的业务的数据库部署到不同的物理服务器上。

### 1.2.8 使用NOSQL和搜索引擎

满足数据存储和检索的需求。
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/NoSQL%E5%92%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E.png)

> NoSQL和搜索引擎对可伸缩的分布式特性具有很好的支持。
> 应用服务器通过一个统一的数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。

### 1.2.9 业务拆分

* 根据产品线划分，讲一个网站拆分成许多不同的应用，每个应用独立部署维护。
* 应用之间通过一个超链接建立关系，也可以通过消息队列进行数据分发。

![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%BA%94%E7%94%A8%E6%8B%86%E5%88%86.png)

### 1.2.10 分布式服务

将相同的业务提取出来，独立部署，由可复用的业务连接数据库，来提供共用业务服务，应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。
![分布式服务](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1.png)

## 1.3 大型网站架构演化的价值观

* 大型网站架构的核心价值是**随网站所需**灵活应对。
* 驱动大型网站技术法阵的主要力量是**网站的业务发展**。

## 1.4 网站架构设计误区

* 以为追随大公司的解决方法：值得学习和借鉴，但是不能盲从。
* 为技术而技术：网站技术是为业务而存在的。
* 企图用技术解决所有问题：技术用来解决业务问题，业务问题也可以通过业务手段来解决。

# 2 大型网站架构模式

## 2.1 网站架构模式

* 问题与挑战：高并发访问、海量数据处理、高可靠运行。
* 目标：高性能、高可用、易伸缩、可扩展、安全。

## 2.1.1 分层

将系统在**横向维度**上切分成几个部分，每个部分负责相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统。

网站软件系统分为：应用层、服务层、数据层。

* 应用层：负责具体业务和视图展示，如网站首页与搜索输入和结果展示。
* 服务层：为应用层提供服务支持，如用户管理服务、购物车服务。
* 数据层：提供数据存储访问服务，如数据库、缓存、文件、搜索引擎。
> 需要严格遵守分层架构的约束，禁止跨层次调用（应用层直接调用数据层）以及逆向调用（数据层调用服务层）。

大的分层结构内部还可以继续分层：

* 应用层可以分为**视图层**和**业务逻辑层**。
* 服务层可以分为**数据接口层**和**逻辑处理层**。

在实际部署上，可以部署在同一个服务器上，也可以分别部署在不同服务器上。

### 2.1.2 分割

对软件在**纵向方面**进行切分。将不同的功能和服务分割开来，包装成高内聚低耦合的模块单元。

### 2.1.3 分布式

分割和分层的一个主要目的是为了切分后的模块便于**分布式部署**，也就是将不同的模块部署在不同的服务器上，通过远程调用协同工作。

解决高并发问题的同时也会带来的一些问题：

* 分布式服务调用必须通过网络，会造成性能影响；
* 服务器越多，宕机的可能性也就越大，也就会造成部署在该部分的应用不可访问，网站可用性降低；
* 数据在分布式环境下保持一致性也是比较困难的；
* 分布式事务难保证；
* 导致网站依赖错综复杂，开发管理维护困难。

常用的分布式方案：

* **分布式应用和服务**：分层和分割后的应用和服务模块分布式部署，不仅改善网站性能和并发性、加快开发和发布速度、减少数据库连接资源消耗，还可以让不同的应用复用共同的服务。
* **分布式静态资源**：将网站的静态资源如JS,CCS,LOGO图片等资源独立分布式部署，并采用独立的域名。静态资源分布式部署可以减轻应用服务器的负载压力；采用独立域名可以加快浏览器并发加载速度。
* **分布式数据和存储**
* **分布式计算**

### 2.1.4 集群

使用分布式虽然可以将分层和分割后的模块独立部署，但是对于用户访问集中的模块，还需要将独立不是的服务器集群化，即多台服务器部署相同的应用构成一个集群，通过负载均衡设备共同对外提供服务。

> 个人理解：
> **分布式和集群的差别** ：分布式就是通过分层和分割将应用进行切分，形成更小的模块，然后这些模块可以部署在不同的服务器上面，这也就是所谓的“分布”的更通俗的含义；集群就是针对一个模块，会同时部署在很多服务其上面，这些服务器共同完成一个功能任务，这几个服务器也就组成一个集群。

### 2.1.5 缓存

缓存就是将数据放在距离计算最近的位置以加快处理速度。

* **CDN**：内容分发网络，部署在距离用户最近的网络服务商，用户请求总是先到达网络服务商那里。网络服务商会缓存网站的一些静态资源（较少变化的数据），以最快速度返回给用户。
* **反向代理**：属于网站前端架构的一部分，部署在网站的前端，当用户请求达到网站的数据中心时，最先访问的就是反向代理服务器。反向代理服务器缓存的是网站的静态资源，无需将请求转发给应用服务器就能返回给用户。
* **本地缓存**：在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，无需访问数据库。
* **分布式缓存**：数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。

使用缓存的因素：

* 数据访问热点不均衡，某些数据访问更频繁；
* 数据某个时间段内有效，否则缓存数据就会因为失效而产生脏读，影响结果的正确性。 

### 2.1.6 异步

系统解耦合的手段：分层、分割、分布、异步。

**异步**：业务之间的消息传递不是同步调用，而是讲一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行执行协作。

实现异步：

* 单一服务器：内部通过多线程共享内存队列的方式实现异步。处在业务操作前面的线程把输出写入到队列，后面的线程从队列中读取数据进行操作
* 分布式系统：多个服务器集群通过分布式消息队列实现异步。分布式消息队列可以看做是内存队列的分布式部署。

异步架构是典型的生产者消费者模式。

使用异步消息队列的特性：

* 提高系统可用性：消费者服务器发生故障，数据会在消息队列服务器中存储堆积，生产者服务器继续处理业务请求，系统整体表现不异常，消费者服务器恢复正常后，仍可以继续处理。
* 加快网站相应速度：生产者服务器将数据写入消息队列后不用等待，可以继续返回响应。
* 消除并发访问高峰：只是消息队列中的请求访问数据增加，等待消费者服务器依次处理即可。

### 2.1.7 冗余

服务器冗余运行、数据冗余备份，保证网站的正常运行。

* **冷备份**：数据库定期备份，存档保存。是指在关闭数据库并且数据库不能更新的状况下进行的数据库完整备份。
* **热备份**：数据库进行主从分离，保证在线业务高可用。是系统处于正常运转状态下的备份。
* **灾备中心**：全球范围部署。

### 2.1.8 自动化

自动化代码管理、自动化测试、自动化安全监测、自动化部署、自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级、自动化分配资源。

### 2.1.9 安全

密码、手机校验码、加密、过滤、风险控制。

# 3 大型网站核心架构要素

5个架构要素：性能、可用性、伸缩性、扩展性、安全性。

## 3.1 性能

提高性能手段：

* 浏览器端：浏览器缓存、页面压缩、合理布局页面、减少Cookies传输。
* CDN：减少访问路径。
* 反向代理：缓存热点文件。
* 应用服务端：本地缓存和分布式缓存，通过缓存在内存中的热点数据处理用户请求，加快请求处理过程。
* 异步操作：将用户请求消息发送至消息队列。
* 集群：多台服务器组成一个集群共同对外服务。
* 代码层面：使用多线程、改善内存管理。
* 数据库服务端：索引、缓存、SQL优化，NOSQL通过优化数据模型、存储结构、伸缩特性等手段。

衡量网站性能指标：响应时间、TPS、系统性能计数器。

## 3.2 可用性

提高可用性手段：主要是冗余

* 应用服务器：多台服务器通过负载均衡设备组成一个集群共同对外服务。
* 存储服务器：对数据进行实时备份。

## 3.3 伸缩性

**伸缩性**：通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。

衡量的主要标准：是否可以用多台服务器构建集群，是否容易向集群中添加服务器。加入新的服务器后能否提供和原来的服务器无差别服务。集群中可容纳的总的服务器数量是否有限制。

## 3.4 扩展性

**扩展性**关注网站的功能需求。

衡量的主要标准：增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或者很少改动既有的业务功能就可以上线新产品。不同产品之间是否很少耦合，一个产品改动，其他产品无影响。

主要手段：事件驱动架构和分布式服务。

**事件驱动架构**：利用消息队列实现。
**分布式服务**：将业务和可复用服务分离，通过分布式服务框架进行调用。新增产品可以通过调用可复用服务实现自身业务逻辑，而对现有产品没有任何影响。可复用服务升级变更时，可以通过提供多版本服务对应用实现透明升级，不需要强制应用同步变更。

## 3.5 安全性

衡量的主要标准：针对现存和潜在的各种攻击与窃密手段，是否有可靠的应对策略。

---

<p align="center"><font size="4">第2篇 架构</font></p>

---

# 4 瞬时响应：网站的高性能架构

## 4.1 网站性能测试

性能测试是性能优化的前提和基础，也是性能优化结果的检查和度量标准。

### 4.1.1 不同视角下的网站性能

1. 用户角度
   
   网站响应的时间。
   ![用户网站角度性能](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E7%94%A8%E6%88%B7%E8%A7%92%E5%BA%A6%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD.png)
   优化手段：前端架构优化手段，优化HTML式样、利用浏览器端的并发和异步特性。

2. 开发人员角度
   
   关注应用程序本身与相关子系统性能，包括响应延时、系统吞吐量、并发处理能力、系统稳定性等技术指标。
   
   主要优化是手段：利用缓存加速数据读取，使用集群提高吞吐量，使用异步消息加快请求响应以及实现削峰，优化代码改善性能等手段。

3. 运维人员角度
   
   关注基础设施性能和资源利用率。如：带宽、硬件配置、网络架构、服务器和带宽的利用率等。
   优化手段：建设优化骨干网、高性比服务器、虚拟化技术优化资源利用率。

### 4.1.2 性能测试指标

主要指标：响应时间、并发数、吞吐量、性能计算器等。

1. 响应时间
   
   发送请求到收到响应的时间间隔。一般测试多次取平均值。
   
2. 并发数
   
   同时处理请求的数目。

3. 吞吐量
   
   单位时间内处理的请求数量。

4. 性能计数器
   
   描述服务器或者操作系统性能的一些数据指标。包括：System Load、对象与线程数、内存使用、CPU使用、磁盘与网络I/O等指标。System Load即系统负载，指当前正在被CPU执行和等待被CPU执行的进程数目总和，是反映系统闲忙程度的重要指标。

### 4.1.3 性能测试方法

可分为：性能测试、负载测试、压力测试、稳定性测试。

1. 性能测试
   
   以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在可接受范围内，是否能达到性能预期。

2. 负载测试
   
   不断增加并发请求，知道系统某项和多项性能指标达到安全临界值。

3. 压力测试
   
   超过安全负载的情况下，对系统继续施加压力，知道系统崩溃或者不能再处理任何请求来获得系统的最大压力承受能力。

4. 稳定性测试
   
   在特定硬件软件、网络环境条件下，给系统加载一定业务压力，让系统较长时间运行，检测系统是否稳定。

![性能测试曲线](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%9B%B2%E7%BA%BF.png)
对应的并发响应时间曲线：
![并发响应时间曲线](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%B9%B6%E5%8F%91%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%9B%B2%E7%BA%BF.png)

### 4.1.4 性能测试报告

### 4.1.5 性能优化策略

1. 性能分析
   
   检查请求处理的各个环节的日志，分析哪个环节响应时间不合理。-> 然后检查监控数据，分析影响性能的主要原因是内存、磁盘、网络还是CPU，是代码问题还是架构不合理，或是系统资源确实不足。

2. 性能优化
   
   分为：Web前端性能优化、应用服务器性能优化、存储服务器性能优化。

## 4.2 Web前端性能优化

Web前端指网站业务逻辑之前的部分，包括：浏览器加载、网站视图模型、图片服务、CDN服务。

主要优化手段：优化浏览器访问、反向代理、CDN。

### 4.2.1 浏览器访问优化

1. 减少http请求
   
   主要手段：合并CSS、JavaScript、图片成一个文件，这样浏览器只需要请求一次。多张图片可以合成一张，如果每张图片都有不同的超链接，可通过CSS便宜响应鼠标点击操作，构造不同的URL。

2. 使用浏览器缓存
   
   CSS、JavaScript、Logo、图标这些静态资源文件更新频率都比较低，而这些文件几乎是每次http请求都是需要的，如果将这些文件缓存在浏览器中，可以较好地改善性能。通过设置HTTP头中Cache-Control和Expires属性，可设定浏览器缓存时间。

   有时候静态资源文件变化需要及时或者立马进行更新，这种时候可以通过改变文件名来实现，即更新JavaScript文件而并不是更新JS文件内容，而是生成一个新的JS文件并更新HTML文件中的引用。

   在更新静态资源的时候，应采用批量更新方法，比如更新10个图标文件，不宜把10个文件一次全部更新，而是一个一个文件逐步更新，并有一定的间隔时间，以免用户浏览器突然大量缓存失效，集中更新缓存，造成服务器负载骤增、网络堵塞的情况。

3. 启用压缩
   
   服务器端进行压缩，浏览器端对文件进行解压，可有效减少通信传输的数据量。

4. CSS放在页面最上面、JavaScript放在页面最下面
   
   浏览器会下载完全部CSS之后才对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面。JavaScrpit则相反，浏览器在加载JS后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此放在页面最下面。但如果页面解析时要用到JavaScprit，这时候放在底部就不合适了。

5. 减少Cookies传输
   
   一方面，Cookie包含在每次请求和响应中，太大的Cookie会影响数据传输。另一方面，某些静态资源文件的访问，发送Cookie没有意义，可以将静态资源使用独立域名访问，避免请求静态资源时发送Cookie，减少Cookie传输次数。

### 4.2.2 CDN加速

CDN（内容分发网络）本质上也是一中缓存。部署在网络运行商机房。
![利用CDN网站的架构](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%88%A9%E7%94%A8CDN%E7%BD%91%E7%AB%99%E7%9A%84%E6%9E%B6%E6%9E%84.png)

### 4.2.3 反向代理

![利用反向代理的网站架构](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%88%A9%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84.png)

反向代理服务器既可以保护网站安全的作用，又可以通过配置缓存功能加速Web请求。还可以加上负载均衡技术。

## 4.3 应用服务器性能优化

优化手段：缓存、集群、异步。

### 4.3.1 分布式缓存

网站性能优化第一定律：优先考虑使用缓存优化性能。

1. 缓存的基本原理

**缓存**指将数据存储在访问速度高的存储介质中。一方面，因为访问速度高可以减少时间。另一方面，存储已经计算过的数据，就不用再重复进行计算可以直接使用，减少时间。

缓存的本质：一个内存Hash表。数据缓存以Key，Value的形式存储在Hash表中。
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/Hash%E8%A1%A8%E5%AD%98%E5%82%A8%E4%BE%8B%E5%AD%90.png)
> 计算Hash表的索引下标，做简单的就是余数法，Hash表索引 = HashCode % Hash表长度。

缓存主要用来存储读写比例高但是变化很少的数据。

![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E5%AD%98%E5%8F%96%E6%95%B0%E6%8D%AE.png)
> 先从缓存中读取，如果读取不到或者数据失效，在访问数据库，并将数据写入缓存中。

2. 合理使用缓存

避免以下几种情况：

* 频繁修改的数据：写入缓存后，应用还来不及读取，数据就已经失效。
* 没有热点的访问：缓存使用内存作为存储，不可能将所有数据都缓存起来，只能讲最新访问的数据缓存起来，将历史数据清理。
* 数据不一致与脏读：对缓存设置失效时间，一旦超过失效时间，就要从数据库中重新加载。
* 缓存可用性：缓存设计的初衷是提高数据的读取性能，缓存数据丢失或者不可用时不会影响到应用程序处理（可以直接从数据库中读取）。但是大部分数据库访问是完成不能承受如此大的压力而发生宕机。
* 缓存预热：热点数据利用LRU（最近最久未用算法）对不断访问的数据筛选淘汰处理的，这个过程需要花费很长时间。新启动的缓存系统没有任何数据，因此性能都不会太好，最好的方法是在缓存系统启动之前吧热点数据加载好，这个加载手段就叫做**缓存预热**。
* 缓存穿透：持续高并发请求某个不存在的数据。缓存没有该数据，所有请求都会落在数据库上。简单的对策：将一个不存在的数据也缓存起来（value 为 null）

3. 分布式缓存架构
   
缓存部署在多个服务器组成的集群种。其架构有两种方式：JBoss Cache为代表的需要同步更新的分布式缓存；Memcached为代表的互不通信的分布式缓存。

* JBoss Cache：所有服务器中保存相同的缓存数据，当某台服务器有缓存数据更新的时候，会通知集群中其他机器更新缓存数据或者清楚缓存数据。通常将应用程序和缓存部署在同一台服务器上，因此受限于服务器内存空间。多用于企业应用系统中，大型网站少使用。
  
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/JBoss%20Cache.png)

* Memcached：互不通信、海量数据可伸缩。
  
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/Memcached.png)

### 4.3.2 异步操作

使用消息队列将调用异步化。
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%8D%E5%8A%A1%E5%99%A8.png)
> 不使用消息队列，用户请求数据直接写入数据库，造成压力。使用消息队列后，请求发送给消息队列后彼便立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库，具有很好的削峰作用。
  
### 4.3.3 使用集群

使用负载均衡技术为一个应用构建一个有多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上。
![](https://raw.githubusercontent.com/ZoharAndroid/MarkdownImages/master/%E5%88%A9%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%8A%80%E6%9C%AF%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD.png)

### 4.3.4 代码优化

1. 多线程
   
使用多线程的主要原因是：IO阻塞和多CPU。

解决线程安全的主要手段：

* 将对象设计为无状态对象：无状态对象是指对象本身不存储状态信息（对象无成员变量，或者成员变量也是无状态对象）。
* 使用局部对象：方法内部创建对象。
* 并发访问资源时使用锁：通过锁方式使多线程并发操作转化为顺序操作。

2. 资源复用

减少开销很大的系统资源的创建和销毁。比如：数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用的两种模式：**单例模式**和**对象池**。

对象池：数据库连接对象创建好后，将连接对象放入对象池容器中，应用程序要连接的时候，就从对象池中获取一个空闲的连接使用，使用完毕后再将该对象归还到对象池中即可。

3. 数据结构
   

